#pragma once

#include <cstddef>
#include <cstdint>
#include <functional>
#include <random>

#include "assert.hpp"

namespace leekpp
{

/** \addtogroup Mixer
 *  \{
 *
 *  A \e mixer is responsible for transforming an input type \c T into a sequence of bit indices for use in a Bloom
 *  filter. A mixer is a fusion of \c std::hash and a psuedo random number generator.
 *
 *  ### Requirements
 *
 *   - `M` is a \e mixer type
 *   - `m` is an instance of `M`
 *   - `T` is the type of data used to seed an `M`
 *   - `t` is an instance of a `T`
 *   - `sz` is a bit count
 *
 *  | Expression                    | Notes                                                                            |
 *  |:-----------------------------:|:---------------------------------------------------------------------------------|
 *  | `M(t, sz)`                    | Create a mixer. Mixers created with these parameters should generate the same indices. |
 *  | `M::block_bits` -> `size_t`   | How many bits live in a block? A value of 0 means this is a non-blocking mixer.  |
 *  | `m()` -> `size_t`             | Generate the next index in the sequence.                                         |
 *  | `m.base_offset()` -> `size_t` | Get the bit index of the start of the group this mixer will generate. (Only if `block_bits > 0`) |
 *
 *  \see basic_mixer
**/

/** A hash and LC-RNG based mixing function. The hash function is used to transform inputs of type \c T into a number,
 *  which is used to seed the \c TRng. The next index is generated by asking the PRNG to generate the next value.
 *
 *  \tparam T The type of values this mixer should accept.
 *  \tparam THash Function to use to transform a \c T into a seed value. \c THash::result_type must be usable to
 *   construct a \c TRng.
 *  \tparam TRng A psuedo random number generator used to generate values.
**/
template <typename T,
          typename THash = std::hash<T>,
          typename TRng  = std::minstd_rand
         >
class basic_mixer :
        private THash
{
public:
    /** How many bits live in a block? A value of 0 means this mixer does not generate bit indices in groups.
     *
     *  \see basic_cache_aligned_mixer
    **/
    static constexpr std::size_t block_bits = 0;

public:
    explicit basic_mixer(const T& val, std::size_t bit_count, const THash& hash = THash()) :
            THash(hash),
            _bit_count(bit_count),
            _rng(THash::operator()(val))
    { }
    
    std::size_t operator()()
    {
        return _rng() % _bit_count;
    }
    
private:
    std::size_t _bit_count;
    TRng        _rng;
};

/** A mixing function which generates sequences of indices which are more friendly to the CPU cache.
 *
 *  One of the biggest problems with Bloom filters is they completely thrash your cache. Since an ideal hash function
 *  jumps around memory in a random-looking fashion, your CPU will spend all its time waiting on bits to load from
 *  memory. Felix Putze, Peter Sanders and Johannes Singler proposed alternative methods of Bloom filter hashing in
 *  [Cache-, Hash- and Space-Efficient Bloom Filters](http://algo2.iti.kit.edu/documents/cacheefficientbloomfilters-jea.pdf)
 *  which helps address this problem without lowering effective FPR.
 *
 *  \tparam T The type of values this mixer should accept.
 *  \tparam KAlignBits The bit alignment used to group index sequences. This \e must be compatible with the
 *   \c storage_type::block_size and \e should be a multiple of a cache line for your CPU architecture (the default of
 *   512 is 64 bytes, which is the cache line size on modern x86 systems). If this value is too large, you lose the
 *   caching advantages of grouping; if this is too small, it will affect FPR.
 *  \tparam THash Function to use to transform a \c T into a seed value. \c THash::result_type must be usable to
 *   construct a \c TRng.
 *  \tparam TRng A psuedo random number generator used to generate values.
**/
template <typename    T,
          std::size_t KAlignBits = 512,
          typename    THash = std::hash<T>,
          typename    TRng  = std::minstd_rand
         >
class basic_cache_aligned_mixer :
        private THash
{
public:
    static constexpr std::size_t block_bits = KAlignBits;
    static_assert(block_bits > 1, "Alignment too low");

public:
    
    explicit basic_cache_aligned_mixer(const T& val, std::size_t bit_count, const THash& hash = THash()) :
            THash(hash),
            _rng(THash::operator()(val)),
            _base_offset((_rng() % (bit_count / KAlignBits)) * KAlignBits)
    {
        LEEK_ASSERT(bit_count % KAlignBits == 0,
                    invalid_argument,
                    ("The bit count %uz is not divisible by alignment %uz", bit_count, KAlignBits)
                   );
    }

    std::size_t base_offset() const
    {
        return _base_offset;
    }
    
    std::size_t operator()()
    {
        return _base_offset + (_rng() % KAlignBits);
    }
    
private:
    TRng        _rng;
    std::size_t _base_offset;
};

/** \} **/

}
